# Project Context

This file is auto-generated by Puffin to provide context to Claude Code.

## Project Overview

**Project:** puffin

Puffin is an Electron-based GUI application that serves as a **management layer** on top of the Claude Code CLI (3CLI). Its primary purpose is to:

1. **Track and organize** 3CLI outputs and conversations
2. **Provide context** to 3CLI through project configuration and history
3. **Visualize** the development process (prompts, responses, branches)
4. **Communicate UI designs** via the GUI designer

**Important**: 3CLI remains in control of building the project. Puffin is an orchestration and tracking tool, not a replacement for the CLI's capabilities.

## File Access Restrictions

**IMPORTANT: You must ONLY access files within this project directory.**

You are NOT allowed to:
- Read, write, or modify files outside this project
- Access parent directories or sibling projects
- Reference or use files from other projects on the system
- Execute commands that affect files outside the project root

All file operations must be scoped to this project directory and its subdirectories.

## Coding Preferences

- **Programming Style:** Hybrid (OOP + FP)
- **Testing Approach:** Behavior-Driven Development
- **Documentation Level:** Standard
- **Error Handling:** Exceptions
- **Naming Convention:** camelCase
- **Comment Style:** JSDoc

## Completed User Stories

The following stories have been completed and are available for reference:

- **Design Document Directory Scanning**: As a user, I want Puffin to automatically scan the docs/ directory so that available design documents are discovered without manual configuration
- **Design Document Dropdown Selection**: As a user, I want a dropdown menu populated with design documents from the docs/ directory so that I can easily select and include relevant documentation in my conversation
- **Design Document Content Inclusion**: As a user, I want to include a selected design document in my prompt context so that Claude has access to relevant specifications during our discussion
- **Sprint Story Completion Button**: As a user, I want a completion checkmark button on each sprint story card so that I can manually mark stories as complete and sync with the backlog
- **Sprint Progress Based on Story Completion**: As a user, I want the sprint progress bar to reflect the percentage of completed stories so that I can see overall sprint progress regardless of branch work
- **Acceptance Criteria Checklist Display**: As a user, I want to see acceptance criteria as a checklist in the sprint story cards so that I can track granular progress within each story
- **Three-Column Swimlane Layout**: As a user, I want the prompt view to be organized into three vertical swimlanes so that I can see sprint context, conversation, and metadata simultaneously
- **Left Swimlane - Sprint Context Panel**: As a user, I want the left swimlane to display sprint information and user stories so that I can see the current work context while prompting
- **Left Swimlane - Story Completion Indicators**: As a user, I want to see completion indicators for each user story so that I can track progress at a glance
- **Middle Swimlane - Conversation View**: As a user, I want the middle swimlane to contain the existing prompt controls and conversation so that my primary workflow remains unchanged
- **Right Swimlane - Handoff Summary Display**: As a user, I want the right swimlane to display handoff summaries so that I can see context passed from other threads
- **Right Swimlane - Thread Statistics**: As a user, I want to see thread statistics in the right swimlane so that I can monitor resource usage and conversation metrics
- **Default Maximum Iterations Configuration**: As a user, I want the system to default to 10 maximum iterations so that sprint execution has a sensible limit without manual configuration
- **Auto-Continue Delay Configuration**: As a user, I want a 20 second delay between auto-continues so that I have time to review output before the next iteration begins
- **Stuck Detection Threshold**: As a user, I want the system to detect when execution is stuck after 3 similar iterations so that I am alerted to potential issues
- **Sprint Story Limit Enforcement**: As a user, I want the system to reject sprints with more than 4 stories so that I avoid exceeding token limits during execution
- **Sprint Creation from Selected User Stories**: As a user, I want to select one or more user stories from the Backlog and create a sprint so that I can group related work for implementation
- **Sprint Header Display in Prompt Window**: As a user, I want to see the selected user stories displayed in a header section at the top of the prompt window so that I have constant visibility of what I'm working on
- **Sprint Planning Phase with Plan Button**: As a user, I want a 'Plan' button available in the sprint view so that I can initiate the planning phase for the selected user stories
- **Sprint Plan Review and Modification**: As a user, I want to review and modify the generated plan through follow-up prompts so that I can refine the implementation approach before starting work
- **Implementation Branch Buttons per User Story**: As a user, I want to see implementation branch buttons below each user story header so that I can start focused implementation work on specific areas
- **Start Implementation from Branch Button**: As a user, I want to click a branch button to start implementation so that a new turn is added to the current sprint thread with the appropriate context
- **Sprint State Persistence**: As a user, I want the sprint state to persist so that I can return to a sprint and continue work where I left off
- **Sprint Progress Tracking per Story**: As a user, I want to see the implementation progress for each user story within the sprint so that I know what work remains
- **Existing Prompt View Compatibility**: As a user, I want the existing prompt view to continue working as before so that I can still use free-form prompting without creating a sprint
- **Handoff Persistence Without Expiration**: As a user, I want handoffs to persist indefinitely until I explicitly delete them so that I don't lose context due to automatic expiration
- **Handoff Summary Updates**: As a user, I want handoff summaries to be updated as I refine my work so that code changes and bug fixes are reflected in the handoff context
- **Multi-Hop Handoff Chaining**: As a user, I want to chain multiple handoff summaries together so that context is preserved across multiple handoff sequences
- **Handoff Ready Button in Prompt Area**: As a user, I want a 'Handoff Ready' button to appear below the prompt input so that I can initiate a handoff when I decide the work is ready
- **Handoff Review Modal**: As a user, I want to review the handoff summary in a modal before completing the handoff so that I can verify the context being passed to the new thread
- **User-Controlled Handoff Timing**: As a user, I want to control when a handoff occurs regardless of Claude's completion assessment so that I can fix bugs and refine features before handing off
- **Git Repository Detection**: As a user, I want Puffin to detect when my project is in a Git repository so that Git integration features are available when applicable
- **Create New Feature Branch**: As a user, I want to create a new feature branch from the current branch so that I can isolate my work for a new feature implementation
- **Stage and Commit Changes**: As a user, I want to stage and commit my implemented code changes so that I can save my work with a meaningful commit message
- **Merge Feature Branch to Main**: As a user, I want to merge my feature branch into the main branch so that my completed work is integrated into the primary codebase
- **Post-Merge Branch Workflow**: As a user, I want Puffin to help me prepare for the next feature after a successful merge so that I can maintain a clean workflow
- **Git Operation History Log**: As a user, I want to see a log of Git operations performed through Puffin so that I can track what actions have been taken

# Plugin Development Context

You are working on **plugin development** for Puffin. This context provides guidelines and architecture patterns to ensure plugins are robust, maintainable, and follow established conventions.

## Plugin Architecture Overview

Puffin uses a lightweight, convention-based plugin system that supports both **Electron main process** and **renderer process** plugins. Plugins extend Puffin's functionality without modifying core code.

### Key Principles

1. **Convention over Configuration**: Plugins follow naming and structure conventions
2. **Isolation**: Each plugin operates independently with clear boundaries
3. **Lifecycle Management**: Plugins have explicit initialization and cleanup phases
4. **Error Resilience**: Plugin failures should not crash the application
5. **Minimal Dependencies**: Plugins should minimize coupling to core code

## Plugin Types

### Main Process Plugins
- Located in `plugins/*-plugin/main.js`
- Run in Electron's main process (Node.js environment)
- Access to file system, OS APIs, and IPC
- Examples: file watchers, system integration, background tasks

### Renderer Process Plugins
- Located in `plugins/*-plugin/renderer.js`
- Run in the browser context
- Access to DOM, UI components, and renderer IPC
- Examples: UI components, modal dialogs, visual extensions

## Plugin Structure

```
plugins/
└── my-feature-plugin/
    ├── main.js          # Main process code (optional)
    ├── renderer.js      # Renderer process code (optional)
    ├── package.json     # Plugin metadata
    └── README.md        # Plugin documentation
```

### Required Exports

**Main Process (`main.js`)**:
```javascript
module.exports = {
  name: 'my-feature-plugin',
  
  // Initialize plugin
  async initialize(context) {
    // context: { ipcMain, app, mainWindow, config, pluginDir }
  },
  
  // Cleanup on shutdown
  async cleanup() {
    // Release resources, clear timers, etc.
  }
};
```

**Renderer Process (`renderer.js`)**:
```javascript
module.exports = {
  name: 'my-feature-plugin',
  
  // Initialize plugin
  async initialize(context) {
    // context: { ipcRenderer, document, window, config, pluginDir }
  },
  
  // Cleanup on shutdown
  async cleanup() {
    // Remove event listeners, clear state, etc.
  }
};
```

## Plugin Loading System

Plugins are loaded by:
1. **Main process**: `src/main/plugin-loader.js`
2. **Renderer process**: `src/renderer/plugin-loader.js`

Both loaders:
- Scan `plugins/` directory for `*-plugin` folders
- Load and validate plugin modules
- Call `initialize()` with context
- Handle errors gracefully (log and continue)
- Track loaded plugins for cleanup

## IPC Communication Pattern

Plugins use IPC channels prefixed with their name:

**Main Process**:
```javascript
ipcMain.handle('my-feature:get-data', async (event, args) => {
  return { data: 'value' };
});
```

**Renderer Process**:
```javascript
const result = await window.api.invoke('my-feature:get-data', args);
```

**Security**: All IPC handlers must validate input and sanitize output.

## Context Injection

### Main Process Context
```javascript
{
  ipcMain,           // Electron IPC main
  app,               // Electron app instance
  mainWindow,        // BrowserWindow instance
  config,            // Application configuration
  pluginDir          // Absolute path to plugin directory
}
```

### Renderer Process Context
```javascript
{
  ipcRenderer,       // Electron IPC renderer (via preload)
  document,          // DOM document
  window,            // Window object
  config,            // Application configuration
  pluginDir          // Relative path to plugin directory
}
```

## Error Handling

### Plugin-Level Errors
- Wrap async operations in try-catch
- Log errors with plugin name prefix
- Return safe defaults on error
- Never throw unhandled exceptions

**Example**:
```javascript
async initialize(context) {
  try {
    await this.setup(context);
  } catch (error) {
    console.error('[my-feature-plugin] Initialization failed:', error);
    // Continue with degraded functionality
  }
}
```

### Loader-Level Errors
- Plugin load failures are logged but don't stop other plugins
- Missing exports are reported clearly
- Invalid plugins are skipped

## Testing Plugins

### Unit Tests
- Place in `tests/plugins/`
- Name: `<plugin-name>.test.js`
- Mock Electron APIs (ipcMain, ipcRenderer)
- Test initialization, cleanup, and core functionality

**Example**:
```javascript
// tests/plugins/my-feature.test.js
const plugin = require('../../plugins/my-feature-plugin/main.js');

describe('my-feature-plugin', () => {
  it('should initialize without errors', async () => {
    const context = { ipcMain: mockIpcMain, ... };
    await expect(plugin.initialize(context)).resolves.not.toThrow();
  });
});
```

### Integration Tests
- Test IPC communication between main and renderer
- Verify UI integration if applicable
- Test error scenarios

## UI Integration Patterns

### Modal Dialogs
Use the centralized `ModalManager`:

```javascript
const ModalManager = require('./lib/modal-manager.js');

ModalManager.show({
  title: 'My Feature',
  content: '<p>Content here</p>',
  buttons: [
    { label: 'OK', primary: true, action: () => { /* handle */ } },
    { label: 'Cancel', action: () => { /* handle */ } }
  ]
});
```

### DOM Manipulation
- Use `document.querySelector()` for element selection
- Attach event listeners in `initialize()`
- Remove listeners in `cleanup()`
- Namespace CSS classes: `.my-feature-*`

### State Management
- Store plugin state in closure or module-level variables
- Persist state via IPC to main process if needed
- Clean up state in `cleanup()`

## Configuration

### Plugin-Specific Config
Store in `plugins/<plugin-name>/config.json`:

```json
{
  "enabled": true,
  "options": {
    "feature1": true,
    "timeout": 5000
  }
}
```

Access via context:
```javascript
async initialize(context) {
  const config = require(path.join(context.pluginDir, 'config.json'));
  this.timeout = config.options.timeout;
}
```

## Common Patterns

### File System Access (Main Process)
```javascript
const fs = require('fs').promises;
const path = require('path');

async initialize(context) {
  const filePath = path.join(context.pluginDir, 'data.json');
  const data = await fs.readFile(filePath, 'utf-8');
}
```

### Timer Management
```javascript
initialize(context) {
  this.timerId = setInterval(() => {
    // periodic task
  }, 1000);
}

cleanup() {
  if (this.timerId) clearInterval(this.timerId);
}
```

### Event Subscriptions
```javascript
initialize(context) {
  this.handler = (event, data) => { /* handle */ };
  context.ipcMain.on('some-event', this.handler);
}

cleanup() {
  if (this.handler) {
    context.ipcMain.removeListener('some-event', this.handler);
  }
}
```

## Documentation Requirements

Each plugin must include:

### README.md
- Purpose and functionality
- Installation (if any special steps)
- Configuration options
- IPC channels exposed
- Known limitations

### Inline Comments
- JSDoc for public methods
- Explain complex logic
- Document IPC contracts

## Security Considerations

1. **Input Validation**: Validate all IPC inputs
2. **Path Traversal**: Use `path.resolve()` and validate paths
3. **Command Injection**: Never execute shell commands from user input
4. **XSS Prevention**: Sanitize any HTML content injected into DOM
5. **Principle of Least Privilege**: Request minimum permissions needed

## Plugin Checklist

Before committing a new plugin:

- [ ] `package.json` with name, version, description
- [ ] Proper exports (name, initialize, cleanup)
- [ ] Error handling in initialize and cleanup
- [ ] IPC channels prefixed with plugin name
- [ ] Event listeners removed in cleanup
- [ ] Timers/intervals cleared in cleanup
- [ ] README.md documentation
- [ ] Unit tests in `tests/plugins/`
- [ ] No hardcoded paths (use context.pluginDir)
- [ ] Input validation on all IPC handlers

## Debugging

### Main Process
```javascript
async initialize(context) {
  console.log('[my-feature-plugin] Initializing with context:', context);
  // Use Chrome DevTools for main process debugging
}
```

### Renderer Process
- Open DevTools: View → Toggle Developer Tools
- Console logs appear in DevTools
- Use breakpoints for step debugging

### Common Issues
- **Plugin not loading**: Check naming convention (`*-plugin`)
- **IPC not working**: Verify channel names match exactly
- **Memory leaks**: Ensure cleanup() removes all listeners
- **State not persisting**: Main process should handle persistence

## Example Plugin Templates

### Minimal Main Process Plugin
```javascript
// plugins/example-plugin/main.js
module.exports = {
  name: 'example-plugin',
  
  async initialize(context) {
    console.log('[example-plugin] Initialized');
    
    context.ipcMain.handle('example:ping', async () => {
      return { status: 'pong' };
    });
  },
  
  async cleanup() {
    console.log('[example-plugin] Cleaned up');
  }
};
```

### Minimal Renderer Process Plugin
```javascript
// plugins/example-plugin/renderer.js
module.exports = {
  name: 'example-plugin',
  
  async initialize(context) {
    console.log('[example-plugin] Renderer initialized');
    
    const button = document.createElement('button');
    button.textContent = 'Test Plugin';
    button.addEventListener('click', async () => {
      const result = await window.api.invoke('example:ping');
      console.log(result);
    });
    document.body.appendChild(button);
  },
  
  async cleanup() {
    // Remove UI elements if needed
  }
};
```

## Resources

- Plugin loader: `src/main/plugin-loader.js`, `src/renderer/plugin-loader.js`
- Modal system: `src/renderer/lib/modal-manager.js`
- IPC preload: `src/main/preload.js`
- Example plugin: `plugins/claude-config-plugin/`

---

**Remember**: Plugins should enhance Puffin without compromising stability. When in doubt, favor simplicity and robustness over complexity.