# Puffin High-Level View

**Version**: 3.0.0
**Architecture**: Electron + SQLite + Plugin System + Central Reasoning Engine (CRE)

Puffin is an orchestration layer for Claude Code CLI that transforms AI-assisted development from ad-hoc prompting into a structured, deterministic workflow. It provides intelligent planning, context management, and automated implementation orchestration.

## What is Puffin?

Puffin is an Electron-based GUI application that serves as a **management and reasoning layer** on top of Claude Code CLI. It doesn't replace Claude Code—it orchestrates and tracks its outputs while providing rich context and deterministic implementation specifications.

**Core Architecture (v3.0.0):**
- **Central Reasoning Engine (CRE)**: Transforms user stories into deterministic implementation plans and Ready-to-Implement Specifications (RIS)
- **SQLite Database**: All state persisted in `.puffin/puffin.db` (13 tables, 9 migrations)
- **Plugin System**: Modular architecture with official plugins (Excalidraw, Memory, h-DSL Viewer, Outcome Lifecycle, RLM Document)
- **h-DSL Code Model**: Hybrid DSL tracking codebase structure, updated after each implementation via MCP integration
- **Branch Memory**: Automated knowledge extraction and injection per branch

**Key Principles:**
- Claude Code remains in control of building the project
- CRE provides deterministic, testable specifications
- All state persisted to SQLite database
- Dynamic context generated based on active branch
- Plugin architecture for extensibility

## The Puffin Workflow (v3.0.0)

<img src="workflows/end-to-end workflow.png" alt="End-to-End Workflow" width="50%">

Puffin implements a deterministic development pipeline powered by CRE:

```
SPECIFY → DERIVE STORIES → CREATE SPRINT → CRE PLAN → CRE RIS → ORCHESTRATE IMPLEMENTATION → CODE REVIEW → DEPLOY
```

**What Changed in v3.0.0:**
- **CRE Two-Stage Planning**: Plan generation (high-level) → RIS generation (implementation directives)
- **Automated Orchestration**: Multi-turn implementation with automatic continuation and stuck detection
- **Code Model Updates**: h-DSL introspection after each story completion
- **Inspection Assertions**: Testable verification criteria generated by CRE
- **Completion Summaries**: AI-generated summaries with metrics (files modified, cost, duration, test status)

Each phase has dedicated tooling, and CRE ensures Claude Code receives deterministic, testable specifications.

---

## Phase 1: Specification & Requirements

<img src="workflows/phase 1 specify and derive.png" alt="Phase 1: Specify and Derive" width="50%">

The **Specifications branch** is a planning-only space where you:
- Describe features and requirements in natural language
- Discuss requirements with Claude for clarification
- Establish project scope and constraints

**Important:** The Specifications branch does NOT allow code changes. It's reserved for planning, documentation, and user story generation.

### Key Actions:
- Write requirements or feature descriptions
- Claude analyzes and asks clarifying questions
- Responses are saved to conversation history

---

## Phase 2: User Story Derivation

<img src="workflows/phase 2 user story derivation.jpg" alt="Phase 2: User Story Derivation" width="50%">

From your specifications, Puffin derives structured user stories using Claude Code CLI:

1. **Click "Derive User Stories"** button in prompt area
2. **Claude analyzes** the specification using bidirectional streaming
3. **Review in modal** - edit, accept, or request changes
4. **Add to backlog** - stories are persisted to `user_stories` table in SQLite database

Each user story includes:
- **Title**: Brief descriptive name
- **Description**: "As a [role], I want [feature] so that [benefit]"
- **Acceptance Criteria**: Testable conditions for completion
- **Inspection Assertions**: Generated by CRE (FILE_EXISTS, PATTERN_MATCH, EXPORT_EXISTS, etc.)
- **Status**: pending → in-progress → completed → archived
- **Completion Summary**: AI-generated summary with metrics (added on completion)

**v3.0.0 Addition**: Stories automatically get inspection assertions when added to sprints, providing automated verification criteria.

---

## Phase 3: Sprint Planning with CRE

<img src="workflows/phase 3 sprint creation and planning.png" alt="Phase 3: Sprint Creation and Planning" width="50%">

Sprints provide focused implementation cycles powered by CRE:

1. **Select stories** from the backlog (maximum 4 per sprint)
2. **Create sprint** - stored in `sprints` table with UNIQUE active sprint constraint
3. **CRE generates plan** using h-DSL Code Model analysis:
   - **Implementation Plan**: Ordered story sequence with branch strategy
   - **Technical Approach**: File changes, dependencies, risks per story
   - **Inspection Assertions**: Automated verification criteria (stored in `inspection_assertions` table)
   - **Implementation Order**: Dependency-aware sequencing
4. **Plan Iteration**: Review, ask questions, request refinements (iteration count tracked)
5. **Approve plan** - plan marked approved, RIS generation begins
6. **CRE generates RIS**: One Ready-to-Implement Specification per story
   - Concise, directive specifications
   - Stored in `ris` table linked to plan and story
   - Contains exact implementation instructions for Claude

### CRE Two-Stage Planning
**Stage 1 - Plan**: High-level strategy, story sequencing, branch decisions
**Stage 2 - RIS**: Directive specifications with implementation details per story

### Why 4 Stories Maximum?
To ensure Claude Code has enough context without exceeding token limits, and to keep sprints focused and manageable.

---

## Phase 4: Orchestrated Implementation

<img src="workflows/phase 4 implementation workflow.png" alt="Phase 4: Implementation Workflow" width="50%">

Once plan + RIS are generated, Puffin orchestrates implementation automatically:

1. **Select a story** from the sprint panel
2. **Orchestration starts** with full context:
   - RIS (Ready-to-Implement Specification) from CRE
   - Inspection assertions for verification
   - Story acceptance criteria
   - Branch-specific context (branch memory, design tokens, data models)
   - h-DSL Code Model (codebase structure)
   - Project architecture
3. **Claude implements** using bidirectional streaming
4. **Auto-continuation** manages multi-turn implementation
5. **Completion detection** recognizes `[Complete]` or max turns
6. **Completion summary** generated with metrics:
   - Files modified
   - Test status (passed/failed/skipped)
   - Criteria matched
   - Turn count, cost, duration
7. **Story marked complete** in database
8. **CRE Introspection** updates h-DSL Code Model with changes

### Sprint Orchestration System
Puffin's orchestration system automates the implementation loop:
- **Automated Continuation**: Detects incomplete responses and continues (20s wait with countdown)
- **Stuck Detection**: Alerts if output becomes repetitive (compares last 200 chars)
- **Max Turns**: Configurable continuation limit (default varies by operation)
- **File Tracking**: Monitors file operations during implementation
- **Cancel Protection**: Confirmation dialog if files were modified
- **Session Resume**: Continue from where you left off using `--resume <sessionId>`

### Implementation Journey Tracking
Each implementation is tracked in `implementation_journeys` table:
- Turn count and input prompts
- Status (pending/in-progress/completed)
- Started/completed timestamps
- Linked to story via foreign key

### Acceptance Criteria & Assertions
Two-level verification:
1. **Manual Criteria**: User checks off acceptance criteria as verified
2. **Automated Assertions**: Inspection assertions evaluated against codebase
   - FILE_EXISTS, PATTERN_MATCH, EXPORT_EXISTS, CLASS_STRUCTURE, etc.
   - Results stored in `assertion_results` JSON column
   - Displayed in code review phase

---

## Phase 5: Handoff Between Branches

<img src="workflows/phase 5 handoff between branches.png" alt="Phase 5: Handoff Between Branches" width="50%">

Context handoff ensures continuity when moving between branches:

1. **Complete work** on current branch (e.g., UI)
2. **Click "Handoff Ready"** to initiate handoff
3. **Review summary** - Claude generates a context summary
4. **Complete handoff** - summary is attached to the target branch
5. **New thread** receives the handoff context automatically

### Handoff Contents:
- What was implemented
- Key decisions made
- Next steps for the receiving branch
- Any outstanding issues or dependencies

---

## Phase 6: Git Operations & Deployment

<img src="workflows/phase 6 operation and development.png" alt="Phase 6: Operation and Development" width="50%">

Puffin integrates with Git for version control:

### Repository Operations:
- **Branch management**: Create feature branches, checkout, merge
- **Staging**: Stage/unstage files, view diffs
- **Commit**: Claude can generate commit messages from staged changes
- **Push/Pull**: Sync with remote repositories

### Commit Message Generation:
Claude analyzes staged changes and generates conventional commit messages:
```
feat(auth): implement login form with validation

- Add email/password form fields
- Implement client-side validation
- Display error messages on invalid input
```

All git operations are logged to `.puffin/git-operations.json` for traceability.

---

## Dynamic CLAUDE.md Generation

<img src="workflows/Dynamic Claude.md generation.jpg" alt="Dynamic CLAUDE.md Generation" width="50%">

Puffin generates context files that Claude Code reads automatically:

### Base Context (All Branches):
- Project name and description
- Coding preferences (style, testing, naming conventions)
- Active user stories
- Architecture overview

### Branch-Specific Context:

| Branch | Additional Context |
|--------|-------------------|
| **Specifications** | User story templates, NO CODE CHANGES allowed |
| **Architecture** | System design, API contracts, data models |
| **UI** | Design tokens, component patterns, typography |
| **Backend** | Data models, API patterns, database schema |
| **Deployment** | Infrastructure notes, environment config |

When you switch branches, Puffin regenerates `CLAUDE.md` by combining base + branch content.

---

## Data Artifacts & Persistence (v3.0.0)

<img src="workflows/data_artificats and persistence.png" alt="Data Artifacts and Persistence" width="50%">

**Major Change**: v3.0.0 migrated from JSON files to SQLite database for all transactional data.

### SQLite Database (`.puffin/puffin.db`)

**13 Tables** (9 migrations applied):
- `user_stories` - Active backlog stories with inspection assertions
- `archived_stories` - Soft-deleted stories
- `sprints` - Active sprint (only one allowed, enforced by trigger)
- `sprint_stories` - Junction table (many-to-many)
- `sprint_history` - Archived sprints with denormalized story data
- `plans` - CRE implementation plans (1:1 with sprints)
- `ris` - Ready-to-Implement Specifications per story
- `inspection_assertions` - CRE-generated verification assertions
- `completion_summaries` - Story completion metrics
- `story_generations` - AI story generation history
- `implementation_journeys` - Story implementation tracking
- `_json_migration` - Legacy migration tracking
- `_migrations` - Schema version tracking

### File System (`.puffin/`)

```
.puffin/
├── puffin.db               # SQLite database (primary storage)
├── config.json             # Project settings, preferences
├── history.json            # Conversation branches & prompts
├── architecture.md         # System architecture document
├── git-operations.json     # Git operation history
├── cre/                    # CRE subsystem
│   ├── schema.json         # h-DSL base schema
│   ├── instance.json       # h-DSL code model instance
│   ├── memo.json           # Navigation cache
│   └── plans/              # Plan markdown files
├── memory/
│   └── branches/           # Branch-specific memory files
│       ├── fullstack.md
│       ├── ui.md
│       └── backend.md
├── excalidraw-designs/     # Excalidraw plugin designs
├── outcome-lifecycles/     # Outcome plugin data
└── claude-plugins/         # Plugin configuration
```

### Target Project Context Files

```
target-project/.claude/
├── CLAUDE.md             # Active context (base + branch + memory)
├── CLAUDE_base.md        # Shared project context
├── CLAUDE_specifications.md
├── CLAUDE_architecture.md
├── CLAUDE_ui.md
├── CLAUDE_backend.md
└── CLAUDE_deployment.md
```

**Note**: Branch memory is automatically injected into branch-specific CLAUDE.md files.

---

## Plugin System (v3.0.0)

Puffin v3.0.0 introduces a modular plugin architecture for extensibility:

### Official Plugins

| Plugin | Purpose | Key Features |
|--------|---------|-------------|
| **Excalidraw** | Professional diagramming with AI generation | Hand-drawn aesthetic, 10+ element types, AI diagram generation from markdown, PNG/SVG/JSON export |
| **Memory** | Automated knowledge extraction per branch | Analyzes conversation history, extracts facts/decisions/conventions/bugs, injects into CLAUDE.md |
| **h-DSL Viewer** | Code model visualization | Interactive graph viewport, dependency tracing, architecture navigation |
| **Outcome Lifecycle** | Sprint outcome tracking | Planned/In-Progress/Completed/Failed states, cost/duration metrics |
| **RLM Document** | Recursive Language Model processing | Document chunking, hierarchical query results, session state management |

### Plugin Architecture

Each plugin follows the pattern:
- `puffin-plugin.json` - Manifest (name, version, views, actions, IPC channels)
- `main.js` - Main process logic (IPC handlers, file I/O)
- `renderer.js` - Renderer process UI components
- `components/` - UI components with lifecycle methods

Plugins register via `pluginManager.registerPlugin()` and integrate with:
- IPC system (`context.registerIpcHandler()`)
- Preload bridge (`window.puffin.*`)
- File storage (`.puffin/<plugin-name>/`)
- Toast notifications

### Plugin Storage

Plugins store data in `.puffin/<plugin-name>/`:
- `excalidraw-designs/` - Excalidraw .excalidraw files + thumbnails
- `memory/branches/` - Branch memory markdown files
- `outcome-lifecycles/` - Outcome JSON data
- `cre/` - h-DSL schema, instance, plans

---

## Quick Reference: The Complete Flow

<img src="workflows/tasks - high level view.png" alt="Tasks High Level View" width="50%">

| Step | Action | Outcome |
|------|--------|---------|
| 1 | Write specification | Requirements documented |
| 2 | Derive user stories | Backlog populated (saved to `user_stories` table) |
| 3 | Create sprint (≤4 stories) | Sprint initialized (saved to `sprints` table) |
| 4 | CRE generates plan | Implementation plan created (saved to `plans` table) |
| 5 | Review & iterate plan | Plan refined based on feedback (iteration count tracked) |
| 6 | Approve plan | Plan marked approved, RIS generation triggered |
| 7 | CRE generates RIS | Ready-to-Implement Specifications created (saved to `ris` table) |
| 8 | CRE generates assertions | Inspection assertions created (saved to `inspection_assertions` table) |
| 9 | Start orchestration | Story implementation begins with auto-continuation |
| 10 | Claude implements | Code changes made (tracked in `implementation_journeys` table) |
| 11 | Auto-continuation | Multi-turn implementation until `[Complete]` detected |
| 12 | Completion summary | AI-generated summary with metrics (saved to `completion_summaries` table) |
| 13 | CRE introspection | h-DSL Code Model updated with changes |
| 14 | Evaluate assertions | Assertions verified against codebase (results in `assertion_results` column) |
| 15 | Code review | Review completion summary and assertion results |
| 16 | Handoff context | Branch transition (if needed) |
| 17 | Commit & push | Changes versioned via Git panel |
| 18 | Close sprint | Sprint archived to `sprint_history` table |
| 19 | Merge to main | Feature integrated |

---

## Key Benefits (v3.0.0)

### Core Features (v1.0.0-v2.x)
1. **Structured Workflow**: From idea to deployment with clear phases
2. **Context Persistence**: Never lose conversation history or decisions
3. **Branch-Specific Guidance**: Right context for the right task
4. **Sprint Management**: Focused, manageable implementation cycles
5. **Acceptance Criteria**: Clear definition of done
6. **Handoff Continuity**: Seamless branch transitions
7. **Git Integration**: Version control built into the workflow
8. **Planning-Only Zones**: Specifications branch prevents premature coding

### New in v3.0.0
9. **Central Reasoning Engine (CRE)**: Deterministic, testable implementation specifications
10. **Two-Stage Planning**: High-level plan → Ready-to-Implement Specifications (RIS)
11. **h-DSL Code Model**: Living representation of codebase structure, updated via MCP
12. **Automated Orchestration**: Multi-turn implementation with auto-continuation and stuck detection
13. **Inspection Assertions**: Automated verification (FILE_EXISTS, PATTERN_MATCH, EXPORT_EXISTS, etc.)
14. **Branch Memory**: Automated knowledge extraction and injection per branch
15. **Plugin Architecture**: Extensible system with official plugins (Excalidraw, Memory, h-DSL Viewer, etc.)
16. **SQLite Persistence**: Robust database storage replacing JSON files (13 tables, atomic transactions)
17. **Completion Summaries**: AI-generated summaries with metrics (files, cost, duration, tests)
18. **Bidirectional Streaming**: Interactive question support via stream-JSON format
19. **MCP Integration**: h-DSL engine accessible to Claude via Model Context Protocol

---

## Getting Started (v3.0.0)

1. **Open a project** in Puffin (creates `.puffin/` directory and SQLite database)
2. **Configure** project settings and preferences in config.json
3. **Start on Specifications** branch (planning-only, no code changes)
4. **Write requirements** and click "Derive User Stories" button
5. **Review and add stories** to backlog (saved to `user_stories` table)
6. **Create a sprint** with 1-4 stories (saved to `sprints` table)
7. **CRE generates plan** using h-DSL Code Model
8. **Review plan** and request refinements if needed (iteration tracked)
9. **Approve plan** - triggers RIS and assertion generation
10. **Start orchestration** - Puffin automates implementation with auto-continuation
11. **Monitor progress** - watch orchestration panel for turn count and stuck detection
12. **Review completion** - AI-generated summary with metrics displayed
13. **Code review phase** - evaluate assertions and verify acceptance criteria
14. **Close sprint** - archives to `sprint_history` with all data preserved
15. **Use plugins** - Excalidraw for diagrams, Memory for knowledge extraction, etc.
16. **Commit and push** when features are complete via Git panel

### Key v3.0.0 Differences
- **Database-first**: All state in SQLite, not JSON files
- **CRE-driven**: Let CRE generate plans and RIS, don't manually plan
- **Automated**: Orchestration handles multi-turn implementation
- **Verifiable**: Inspection assertions provide automated verification
- **Observable**: h-DSL Code Model shows current codebase structure
- **Extensible**: Plugins add new capabilities without core changes
