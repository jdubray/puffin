# Memory Plugin — Technical Summary

This document describes the Memory Plugin's complete lifecycle: how branch memory files are created, read, injected into Claude CLI prompts, updated after conversations, and persisted to disk.

## 1. Overview

The Memory Plugin extracts **domain-level knowledge** from branch conversation histories using LLM-powered analysis. Knowledge is categorized into four sections — Facts, Architectural Decisions, Conventions, and Bug Patterns — and stored as markdown files in `.puffin/memory/branches/`. This extracted memory is then injected into `CLAUDE.md` files so that future Claude CLI sessions have project-specific context.

## 2. How Branch Memory Files Are Created

Memory files are created through two paths:

### Automatic (Startup Maintenance)

On every plugin activation, `maintenance.js:startupCheck()` runs in the background (fire-and-forget, non-blocking):

1. **Discover branches**: Queries `historyService.getBranches()` to list all known branches. Uses exponential backoff (up to 6 retries, starting at 2 seconds, max 10 seconds) since the HistoryService may not be ready at plugin activation time.
2. **Find unmemoized branches**: Compares the branch list against existing `.md` files in `.puffin/memory/branches/`, accounting for filename sanitization.
3. **Memorize each**: Calls `memoryManager.memorize(branchId)` for up to 20 branches per startup run (`MAX_BRANCHES_PER_RUN`). Remaining branches are deferred to the next startup.

### Manual (IPC Trigger)

Users can trigger memorization through the UI or programmatically via the `plugin:memory-plugin:memorize` IPC handler, passing a `branchId`. This invokes the same `memoryManager.memorize()` pipeline.

### The Memorize Pipeline

`memory-manager.js:memorize(branchId)` orchestrates a 6-step pipeline:

```
1. READ HISTORY     — historyService.getBranchPrompts(branchId)
                      Returns array of { content, response: { content } } turns

2. CHECK FALLBACKS  — fallbacks.js:checkFallback(prompts)
                      Skips if: no prompts, all responses empty, or
                      fewer than 1 substantive turn (< 50 chars combined)

3. EXTRACT          — LLM extraction with retry (up to 2 retries)
                      Builds extraction prompt → Claude CLI (haiku, --print, maxTurns:1)
                      → Validates JSON response structure

4. READ EXISTING    — fsLayer.readBranch(branchId)
                      Returns { exists, parsed, raw } — ENOENT returns exists:false

5. EVOLVE or CREATE — If existing memory exists:
                        LLM evolution (merge new into existing, deduplicate, resolve conflicts)
                      If no existing memory:
                        Simple extraction-to-sections grouping (no LLM needed)

6. WRITE TO DISK    — fsLayer.writeBranchSections(branchId, sections)
                      Generates markdown via branch-template → atomic write
```

Return statuses: `success`, `skipped` (fallback), `empty` (nothing extracted), `error`.

## 3. How Memory Is Read and Parsed by branch-template.js

`branch-template.js` provides three core functions for working with memory files:

### File Format

Branch memory files are markdown with a strict structure:

```markdown
# Branch Memory: {branchId}

> Auto-generated by Memory Plugin | Last updated: {ISO timestamp}

## Facts

- Cross-cutting technical fact 1
- Cross-cutting technical fact 2

## Architectural Decisions

- Design choice and trade-off 1

## Conventions

- Coding standard or naming pattern 1

## Bug Patterns

- Recurring issue and root cause 1
```

### Section Identifiers

Four sections are defined in `SECTIONS`:

| Section ID | Heading | Purpose |
|------------|---------|---------|
| `facts` | Facts | Cross-cutting technical facts, constraints, glossary |
| `architectural-decisions` | Architectural Decisions | Design choices, trade-offs spanning multiple components |
| `conventions` | Conventions | Coding standards, naming patterns, structural rules |
| `bug-patterns` | Bug Patterns | Recurring issues, root causes affecting multiple areas |

### Parsing (`parse()`)

1. Extracts `branchId` from `# Branch Memory: {branchId}` title line via regex
2. Extracts `lastUpdated` timestamp from `Last updated: {timestamp}` blockquote
3. For each section, calls `extractSectionItems(markdown, heading)`:
   - Matches from `## Heading` to the next `## ` or end-of-string
   - Strips `- ` prefixes from list items
   - Returns empty array for `_No entries yet._` placeholder
4. Returns `{ branchId, lastUpdated, sections }` where `sections` maps section IDs to string arrays

### Generation (`generate()`)

Takes a branchId and optional initial content per section, produces the formatted markdown string with a fresh timestamp.

### Update (`update()`)

Parses existing markdown, merges in new section data (new values replace existing for specified sections, unspecified sections are preserved), then regenerates.

## 4. How Memory Content Is Injected into Claude CLI Prompts

Memory injection happens through `claude-md-generator.js` — the component that assembles `CLAUDE.md` files for the target project.

### Injection Pipeline

When generating a branch-specific `CLAUDE_{branch}.md` file:

1. `generateBranch()` produces the branch's static content (focus areas, patterns, key files)
2. **`getBranchMemoryContent(branch)`** is called to append memory content
3. The result is written to `CLAUDE_{branch}.md`
4. `activateBranch()` concatenates `CLAUDE_base.md` + `CLAUDE_{branch}.md` → `CLAUDE.md`

### Memory Filtering and Truncation

`getBranchMemoryContent()` applies selective filtering:

1. **Graceful import**: `parseBranchMemory` is imported from the memory plugin at module load. If the plugin is absent, the function returns empty string (silently disabled).
2. **File read**: Reads `.puffin/memory/branches/{sanitizedBranch}.md`. Returns empty on `ENOENT`.
3. **Section filtering**: Only three of four sections are included, in priority order:
   - `conventions` (highest priority)
   - `architectural-decisions`
   - `bug-patterns`
   - `facts` is **excluded** — considered less actionable for Claude prompts
4. **Size limit**: Total injected content is capped at `BRANCH_MEMORY_MAX_CHARS` (4000 characters). Sections are included in priority order; if a section would exceed the budget, items are included one-by-one until the cap is reached, then remaining content is dropped.
5. **Output format**: Wrapped under a `## Branch Memory (auto-extracted)` heading with subsections per included section.

### Example Injected Output

```markdown
## Branch Memory (auto-extracted)

### Conventions

- Puffin uses a modular plugin architecture where each plugin follows the pattern...
- Database operations use atomic transactions via immediateTransaction() wrapper...

### Architectural Decisions

- Sprint closure is atomic: archive sprint, update all story statuses...

### Bug Patterns

- On Windows, process.kill('SIGTERM') only kills the shell wrapper...
```

This content appears at the end of `CLAUDE.md`, after the base project context and branch focus sections.

## 5. How Memory Is Updated After Conversations

Memory updates occur through two mechanisms:

### On-Demand Memorization

When the user clicks "Memorize" in the UI or calls the IPC handler, the full memorize pipeline runs for the specified branch. If a memory file already exists, the **evolution path** is triggered.

### Evolution (Merging New Knowledge)

When existing memory is found, `_evolve()` builds an LLM prompt that:

1. Presents the existing sections (current memory state)
2. Presents the new extractions (from the latest conversation analysis)
3. Instructs the LLM to:
   - **Detect conflicts**: Keep newer knowledge, mark old as superseded
   - **Merge compatible**: Combine complementary statements into one
   - **Deduplicate**: Discard extractions already captured
   - **Preserve valid**: Don't remove unless contradicted

The LLM returns:
- `sections`: The complete merged result (all four sections)
- `changes`: An audit log of actions taken (added/updated/removed/kept)

The response is validated (`validateEvolutionResponse()`) before persisting.

### Periodic Maintenance

The `Maintenance` class runs two scheduled tasks tracked via `maintenance-log.json`:

| Task | Interval | Action |
|------|----------|--------|
| Weekly consolidation | 7 days | Re-memorize up to 20 existing branches (re-extracts from latest conversations and evolves) |
| Monthly reindex | 30 days | Same as weekly (extensible for deeper analysis later) |

On startup, `_runStartupCheck()` checks if either task is due based on `maintenance-log.json` timestamps, runs due tasks, and updates the log.

## 6. Persistence Mechanism

### Storage Directory Structure

```
.puffin/
└── memory/
    ├── config.json              — Plugin configuration
    ├── maintenance-log.json     — Maintenance task timestamps
    └── branches/
        ├── fullstack.md         — Branch memory for "fullstack"
        ├── specifications.md    — Branch memory for "specifications"
        ├── feature_auth.md      — Branch memory for "feature/auth" (sanitized)
        └── ...
```

### Storage Initialization (`storage-init.js`)

On first activation, `initialize(projectRoot)` creates the directory tree and default files:

- **`config.json`**: `{ version: 1, enabled: true, autoMemorize: false, model: "haiku", maxPromptsPerExtraction: 50 }`
- **`maintenance-log.json`**: `{ version: 1, lastThreadProcessed: null, lastWeeklyConsolidation: null, lastMonthlyReindex: null }`

Safe to call multiple times — never overwrites existing files.

### File Naming

Branch IDs are sanitized via `sanitizeBranchId()`: any character not in `[a-zA-Z0-9_-]` is replaced with `_`. For example:
- `feature/auth` → `feature_auth.md`
- `bug-fixes` → `bug-fixes.md` (hyphens preserved)

### Atomic Writes

Both `writeBranch()` and `writeJson()` in `file-system-layer.js` use the atomic write pattern:

1. Write to `{file}.tmp`
2. Rename `.tmp` → final path (atomic on most filesystems)
3. On rename failure, clean up `.tmp` and re-throw

This prevents partial writes from corrupting files on crash.

### Branch Memory File Format

Markdown files with structured sections (see Section 3). Each item is a bullet point. Empty sections show `_No entries yet._`.

### Maintenance Log Format

```json
{
  "version": 1,
  "lastThreadProcessed": "2025-01-15T10:30:00.000Z",
  "lastWeeklyConsolidation": "2025-01-12T08:00:00.000Z",
  "lastMonthlyReindex": "2025-01-01T00:00:00.000Z"
}
```

Validated on read — if invalid or corrupted, defaults are used silently.

## 7. Lifecycle Flow

```
┌─────────────────────────────────────────────────────────────────┐
│                        INITIALIZATION                           │
│                                                                 │
│  Plugin activates → storage-init creates directory tree         │
│  → FileSystemLayer(basePath) → MemoryManager → Maintenance     │
│  → IPC handlers registered → startupCheck() fires (async)      │
└──────────────────────┬──────────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────────┐
│                     STARTUP MEMORIZATION                        │
│                                                                 │
│  historyService.getBranches() (with retry)                      │
│  → Compare against existing .md files                           │
│  → For each unmemoized branch (max 20):                         │
│      memorize(branchId) → extract → write .md                   │
│  → Check periodic maintenance (weekly/monthly)                  │
└──────────────────────┬──────────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────────┐
│                          READ                                   │
│                                                                 │
│  claude-md-generator.js:getBranchMemoryContent(branch)          │
│  → Reads .puffin/memory/branches/{branch}.md                    │
│  → Parses via branch-template.parse()                           │
│  → Filters: conventions, arch decisions, bug patterns           │
│  → Truncates to 4000 chars                                      │
└──────────────────────┬──────────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────────┐
│                         INJECT                                  │
│                                                                 │
│  claude-md-generator.js:generateBranch(branch, state, ...)      │
│  → Appends memory content under "## Branch Memory"              │
│  → activateBranch() combines base + branch → CLAUDE.md          │
│  → Claude CLI reads CLAUDE.md on next invocation                │
└──────────────────────┬──────────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────────┐
│                         UPDATE                                  │
│                                                                 │
│  User clicks "Memorize" (or maintenance triggers)               │
│  → memorize(branchId)                                           │
│  → Reads conversation history from HistoryService               │
│  → LLM extraction: conversation → JSON extractions              │
│  → If existing: LLM evolution (merge/dedup/conflict-resolve)    │
│  → If new: simple section grouping                              │
└──────────────────────┬──────────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────────┐
│                        PERSIST                                  │
│                                                                 │
│  fsLayer.writeBranchSections(branchId, sections)                │
│  → branch-template.generate() → markdown string                 │
│  → Atomic write: .tmp → rename                                  │
│  → File at .puffin/memory/branches/{branchId}.md                │
└─────────────────────────────────────────────────────────────────┘
```

## 8. Edge Cases

### Missing Memory File (First-Time Branch)

- `fsLayer.readBranch()` returns `{ exists: false, parsed: null, raw: null }` on `ENOENT`
- `memorize()` takes the "create" path: groups extractions into sections without LLM evolution
- `getBranchMemoryContent()` returns empty string — no memory injected into `CLAUDE.md`

### Empty or Trivial Conversations

`fallbacks.js:checkFallback()` gates extraction:

- **Empty**: No prompts, or all prompts have empty responses → returns `{ reason: 'empty' }`, extraction skipped
- **Trivial**: Fewer than 1 turn with ≥ 50 combined characters (user + response) → returns `{ reason: 'trivial' }`, extraction skipped
- Result: `memorize()` returns `{ status: 'skipped' }` — no file written, no LLM cost

### LLM Extraction Validation Failure

- Extraction is retried up to 2 times (`MAX_RETRIES`) on validation failure
- Validation checks: proper JSON structure, valid section IDs, non-empty content strings, confidence in `[0.0, 1.0]`
- If all retries fail: `memorize()` returns `{ status: 'error' }`

### LLM Evolution Failure

- If evolution validation fails, `memorize()` falls back to simple extraction-to-sections grouping
- Logs warning: "Fell back to simple extraction-to-sections"
- Memory is still written — just without intelligent merging

### Memory Plugin Not Available

- `claude-md-generator.js` uses a try/catch import for `branch-template.js`
- If the plugin is absent or restructured, `parseBranchMemory` is `null`
- `getBranchMemoryContent()` returns empty string — memory injection is silently disabled

### Branch Name Sanitization

- Branch IDs like `feature/auth` are sanitized to `feature_auth` for filesystem safety
- The sanitization applies to both reading and writing, ensuring consistent file lookup

### Transcript Truncation

- Individual conversation turns are capped at 2000 characters each (user and response independently)
- Total transcript is capped at 80,000 characters
- Remaining turns are noted with `[...N remaining turns truncated for length]`

### Claude CLI Not Found

- `ClaudeClient.invoke()` catches `ENOENT` and throws descriptive error: "Claude CLI not found at ... Ensure it is installed and in PATH"
- Rate limit responses are detected and surfaced as specific errors

### Maintenance Branch Cap

- Startup memorization and weekly consolidation process at most 20 branches per run
- Excess branches are deferred to the next startup/maintenance cycle
- Prevents unbounded LLM costs for projects with many branches

## Appendix: IPC Handler Reference

| Handler | Channel | Purpose |
|---------|---------|---------|
| memorize | `plugin:memory-plugin:memorize` | Trigger extraction for a branch |
| get-branch-memory | `plugin:memory-plugin:get-branch-memory` | Read a branch memory file |
| clear-branch-memory | `plugin:memory-plugin:clear-branch-memory` | Delete a branch memory file |
| list-branches | `plugin:memory-plugin:list-branches` | List all branches with memory files |
| run-maintenance | `plugin:memory-plugin:run-maintenance` | Trigger maintenance (weekly/monthly/full) |

## Appendix: File Map

| File | Purpose |
|------|---------|
| `puffin-plugin.json` | Plugin manifest — IPC handlers, renderer component, nav view |
| `index.js` | Entry point — activate/deactivate, history adapter, startup check |
| `lib/memory-manager.js` | Core memorize pipeline — extract, evolve, write |
| `lib/file-system-layer.js` | File I/O — read/write/list/delete with atomic writes |
| `lib/branch-template.js` | Markdown template — generate, parse, update |
| `lib/claude-client.js` | Lightweight Claude CLI client — `--print` single-turn invocation |
| `lib/maintenance.js` | Startup and periodic maintenance — memorize new branches, consolidation |
| `lib/storage-init.js` | First-run directory and config creation |
| `lib/validation.js` | LLM response validation — extraction and evolution schemas |
| `lib/prompts/extraction.js` | Extraction prompt builder — conversation → JSON extractions |
| `lib/prompts/evolution.js` | Evolution prompt builder — merge new into existing memory |
| `lib/prompts/fallbacks.js` | Edge case detection — empty/trivial conversation guards |
| `lib/schemas/maintenance-log.js` | Maintenance log schema — timestamps, validation, isDue() |
| `renderer/components/index.js` | Two-pane UI — branch list sidebar, memory detail view |
| `src/main/claude-md-generator.js` | Memory injection — reads, filters, truncates, appends to CLAUDE.md |
