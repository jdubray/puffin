/**
 * Branch Memory File Template
 *
 * Generates and parses markdown templates for branch memory files.
 * Files are stored at {projectRoot}/.puffin/memory/branches/{branchId}.md
 *
 * @module branch-template
 */

/**
 * Section identifiers used in branch memory files
 * @enum {string}
 */
const SECTIONS = {
  FACTS: 'facts',
  ARCHITECTURAL_DECISIONS: 'architectural-decisions',
  CONVENTIONS: 'conventions',
  BUG_PATTERNS: 'bug-patterns'
}

/**
 * Section metadata for rendering and parsing
 */
const SECTION_META = {
  [SECTIONS.FACTS]: {
    heading: 'Facts',
    description: 'Key facts and domain knowledge extracted from conversations.'
  },
  [SECTIONS.ARCHITECTURAL_DECISIONS]: {
    heading: 'Architectural Decisions',
    description: 'Design choices, trade-offs, and rationale.'
  },
  [SECTIONS.CONVENTIONS]: {
    heading: 'Conventions',
    description: 'Coding standards, naming patterns, and project conventions.'
  },
  [SECTIONS.BUG_PATTERNS]: {
    heading: 'Bug Patterns',
    description: 'Recurring issues, root causes, and fixes.'
  }
}

/**
 * Generate a new branch memory markdown file
 * @param {string} branchId - Branch identifier (e.g. 'specifications', 'ui')
 * @param {Object} [options] - Optional initial content per section
 * @param {string[]} [options.facts] - Initial facts
 * @param {string[]} [options.architecturalDecisions] - Initial architectural decisions
 * @param {string[]} [options.conventions] - Initial conventions
 * @param {string[]} [options.bugPatterns] - Initial bug patterns
 * @returns {string} Markdown content for the branch memory file
 */
function generate(branchId, options = {}) {
  const timestamp = new Date().toISOString()
  const sectionContent = {
    [SECTIONS.FACTS]: options.facts || [],
    [SECTIONS.ARCHITECTURAL_DECISIONS]: options.architecturalDecisions || [],
    [SECTIONS.CONVENTIONS]: options.conventions || [],
    [SECTIONS.BUG_PATTERNS]: options.bugPatterns || []
  }

  const sections = Object.values(SECTIONS).map(sectionId => {
    const meta = SECTION_META[sectionId]
    const items = sectionContent[sectionId]
    const itemsMarkdown = items.length > 0
      ? items.map(item => `- ${item}`).join('\n')
      : '_No entries yet._'

    return `## ${meta.heading}\n\n${itemsMarkdown}`
  }).join('\n\n')

  return `# Branch Memory: ${branchId}\n\n` +
    `> Auto-generated by Memory Plugin | Last updated: ${timestamp}\n\n` +
    `${sections}\n`
}

/**
 * Parse a branch memory markdown file into structured data
 * @param {string} markdown - Raw markdown content
 * @returns {Object} Parsed memory data
 * @returns {string} return.branchId - Branch identifier from the title
 * @returns {string|null} return.lastUpdated - ISO timestamp or null
 * @returns {Object} return.sections - Map of section ID to array of items
 */
function parse(markdown) {
  if (!markdown || typeof markdown !== 'string') {
    return { branchId: null, lastUpdated: null, sections: emptySections() }
  }

  // Extract branch ID from title
  const titleMatch = markdown.match(/^# Branch Memory:\s*(.+)$/m)
  const branchId = titleMatch ? titleMatch[1].trim() : null

  // Extract last updated timestamp
  const timestampMatch = markdown.match(/Last updated:\s*(\S+)/)
  const lastUpdated = timestampMatch ? timestampMatch[1] : null

  // Parse each section
  const sections = {}
  for (const sectionId of Object.values(SECTIONS)) {
    const meta = SECTION_META[sectionId]
    sections[sectionId] = extractSectionItems(markdown, meta.heading)
  }

  return { branchId, lastUpdated, sections }
}

/**
 * Update specific sections in an existing markdown file
 * @param {string} existingMarkdown - Current file content
 * @param {Object} updates - Map of section ID to new items array
 * @returns {string} Updated markdown content
 */
function update(existingMarkdown, updates) {
  const parsed = parse(existingMarkdown)
  const branchId = parsed.branchId || 'unknown'

  // Merge updates into existing sections
  const mergedSections = {}
  for (const sectionId of Object.values(SECTIONS)) {
    mergedSections[sectionId] = updates[sectionId] || parsed.sections[sectionId] || []
  }

  return generate(branchId, {
    facts: mergedSections[SECTIONS.FACTS],
    architecturalDecisions: mergedSections[SECTIONS.ARCHITECTURAL_DECISIONS],
    conventions: mergedSections[SECTIONS.CONVENTIONS],
    bugPatterns: mergedSections[SECTIONS.BUG_PATTERNS]
  })
}

/**
 * Extract list items from a markdown section by heading
 * @param {string} markdown - Full markdown content
 * @param {string} heading - Section heading text (without ##)
 * @returns {string[]} Array of item strings (without leading "- ")
 */
function extractSectionItems(markdown, heading) {
  // Match from "## Heading" to next "## " or end of string
  // Uses greedy match with specific boundary to capture all items in the section
  const pattern = new RegExp(
    `## ${escapeRegex(heading)}\\n\\n([\\s\\S]*?)(?=\\n\\n## |$)`
  )
  const match = markdown.match(pattern)
  if (!match) return []

  const body = match[1].trim()
  if (body === '_No entries yet._') return []

  return body
    .split('\n')
    .map(line => line.replace(/^-\s*/, '').trim())
    .filter(line => line.length > 0)
}

/**
 * @returns {Object} Empty sections map
 */
function emptySections() {
  const sections = {}
  for (const sectionId of Object.values(SECTIONS)) {
    sections[sectionId] = []
  }
  return sections
}

/**
 * Escape special regex characters in a string
 * @param {string} str
 * @returns {string}
 */
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
}

module.exports = {
  SECTIONS,
  SECTION_META,
  generate,
  parse,
  update
}
