/**
 * ClaudeMdGenerator - Generates dynamic CLAUDE.md files for target projects
 *
 * Maintains branch-specific context files that are concatenated into the active CLAUDE.md:
 * - CLAUDE_base.md: Shared project context (description, assumptions, coding preferences)
 * - CLAUDE_{branch}.md: Branch-specific focus and relevant data
 * - CLAUDE.md: Active file = base + current branch content
 */

const fs = require('fs').promises
const path = require('path')

class ClaudeMdGenerator {
  constructor() {
    this.projectPath = null
    this.claudeDir = null
  }

  /**
   * Initialize generator with project path
   * @param {string} projectPath - Path to the target project
   */
  async initialize(projectPath) {
    this.projectPath = projectPath
    this.claudeDir = path.join(projectPath, '.claude')

    // Ensure .claude directory exists
    try {
      await fs.mkdir(this.claudeDir, { recursive: true })
    } catch (err) {
      if (err.code !== 'EEXIST') throw err
    }
  }

  /**
   * Generate all CLAUDE.md files based on current state
   * @param {Object} state - Full Puffin state
   * @param {string} activeBranch - Currently active branch
   * @param {Function} [getSkillContent] - Optional function(branchId) => string to get plugin skill content
   * @param {Function} [getAgentContent] - Optional function(branchId) => string to get agent content
   */
  async generateAll(state, activeBranch, getSkillContent = null, getAgentContent = null) {
    if (!this.projectPath) {
      throw new Error('ClaudeMdGenerator not initialized with project path')
    }

    // Generate base context
    await this.generateBase(state)

    // Generate branch-specific files
    const branches = ['specifications', 'architecture', 'ui', 'backend', 'deployment', 'bug-fixes', 'fullstack', 'code-reviews', 'improvements']
    for (const branch of branches) {
      const skillContent = getSkillContent ? getSkillContent(branch) : ''
      const agentContent = getAgentContent ? getAgentContent(branch) : ''
      await this.generateBranch(branch, state, skillContent, agentContent)
    }

    // Combine into active CLAUDE.md
    await this.activateBranch(activeBranch)
  }

  /**
   * Generate CLAUDE_base.md with shared project context
   * @param {Object} state - Puffin state containing config
   */
  async generateBase(state) {
    const config = state.config || {}
    const lines = []

    lines.push('# Project Context')
    lines.push('')
    lines.push('This file is auto-generated by Puffin to provide context to Claude Code.')
    lines.push('')

    // Project description
    if (config.name || config.description) {
      lines.push('## Project Overview')
      lines.push('')
      if (config.name) {
        lines.push(`**Project:** ${config.name}`)
      }
      if (config.description) {
        lines.push('')
        lines.push(config.description)
      }
      lines.push('')
    }

    // File access restrictions
    lines.push('## File Access Restrictions')
    lines.push('')
    lines.push('**IMPORTANT: You must ONLY access files within this project directory.**')
    lines.push('')
    lines.push('You are NOT allowed to:')
    lines.push('- Read, write, or modify files outside this project')
    lines.push('- Access parent directories or sibling projects')
    lines.push('- Reference or use files from other projects on the system')
    lines.push('- Execute commands that affect files outside the project root')
    lines.push('')
    lines.push('All file operations must be scoped to this project directory and its subdirectories.')
    lines.push('')

    // Assumptions
    if (config.assumptions && config.assumptions.length > 0) {
      lines.push('## Assumptions')
      lines.push('')
      config.assumptions.forEach(assumption => {
        lines.push(`- ${assumption}`)
      })
      lines.push('')
    }

    // Coding preferences
    if (config.options) {
      lines.push('## Coding Preferences')
      lines.push('')
      const opts = config.options
      if (opts.programmingStyle) {
        lines.push(`- **Programming Style:** ${this.formatOption(opts.programmingStyle)}`)
      }
      if (opts.testingApproach) {
        lines.push(`- **Testing Approach:** ${this.formatOption(opts.testingApproach)}`)
      }
      if (opts.documentationLevel) {
        lines.push(`- **Documentation Level:** ${this.formatOption(opts.documentationLevel)}`)
      }
      if (opts.errorHandling) {
        lines.push(`- **Error Handling:** ${this.formatOption(opts.errorHandling)}`)
      }
      if (opts.codeStyle) {
        if (opts.codeStyle.naming) {
          lines.push(`- **Naming Convention:** ${this.formatOption(opts.codeStyle.naming)}`)
        }
        if (opts.codeStyle.comments) {
          lines.push(`- **Comment Style:** ${opts.codeStyle.comments}`)
        }
      }
      lines.push('')
    }

    // Coding Standards (from user-customizable config)
    if (config.codingStandard?.content) {
      lines.push('## Coding Standards')
      lines.push('')
      lines.push(config.codingStandard.content)
      lines.push('')
    }

    // Note: Completed user stories are intentionally NOT included here.
    // They don't provide actionable context for Claude and consume tokens.
    // Historical information belongs in project documentation, not CLAUDE.md.

    const content = lines.join('\n')
    await fs.writeFile(path.join(this.claudeDir, 'CLAUDE_base.md'), content, 'utf-8')
  }

  /**
   * Generate branch-specific CLAUDE_{branch}.md
   * @param {string} branch - Branch name
   * @param {Object} state - Puffin state
   * @param {string} [skillContent=''] - Optional plugin skill content to append
   * @param {string} [agentContent=''] - Optional agent content to append
   */
  async generateBranch(branch, state, skillContent = '', agentContent = '') {
    let content = ''

    switch (branch) {
      case 'specifications':
        content = this.generateSpecificationsBranch(state)
        break
      case 'architecture':
        content = await this.generateArchitectureBranch(state)
        break
      case 'ui':
        content = this.generateUiBranch(state)
        break
      case 'backend':
        content = this.generateBackendBranch(state)
        break
      case 'deployment':
        content = this.generateDeploymentBranch(state)
        break
      case 'bug-fixes':
        content = this.generateBugFixesBranch(state)
        break
      case 'fullstack':
        content = this.generateFullstackBranch(state)
        break
      case 'code-reviews':
        content = this.generateCodeReviewsBranch(state)
        break
      case 'improvements':
        content = this.generateImprovementsBranch(state)
        break
      default:
        content = this.generateGenericBranch(branch, state)
    }

    // Append assigned plugin skills if any are provided
    if (skillContent) {
      content += '\n' + skillContent + '\n'
    }

    // Append assigned agents if any are provided
    if (agentContent) {
      content += '\n' + agentContent + '\n'
    }

    await fs.writeFile(
      path.join(this.claudeDir, `CLAUDE_${branch}.md`),
      content,
      'utf-8'
    )
  }

  /**
   * Generate specifications branch context
   */
  generateSpecificationsBranch(state) {
    const lines = []
    lines.push('---')
    lines.push('')
    lines.push('## Branch Focus: Specifications')
    lines.push('')
    lines.push('You are working on the **specifications thread**. Focus on:')
    lines.push('- Requirements gathering and clarification')
    lines.push('- Feature definitions and scope')
    lines.push('- User stories and acceptance criteria')
    lines.push('- Business logic and rules')
    lines.push('- Edge cases and constraints')
    lines.push('')
    lines.push('**IMPORTANT: NO CODE CHANGES ALLOWED**')
    lines.push('')
    lines.push('This is a planning-only thread. You must NOT:')
    lines.push('- Create, modify, or delete any source code files')
    lines.push('- Make changes to implementation files (.js, .ts, .py, .css, .html, etc.)')
    lines.push('- Execute code or run build/test commands')
    lines.push('')
    lines.push('You MAY only:')
    lines.push('- Generate user stories and acceptance criteria')
    lines.push('- Create implementation plans and technical specifications')
    lines.push('- Produce documentation in markdown format')
    lines.push('- Answer questions and clarify requirements')
    lines.push('- Analyze existing code to inform planning (read-only)')
    lines.push('')
    lines.push('If asked to implement something, explain that implementation should happen')
    lines.push('in the appropriate branch (UI, Backend, or a feature branch) after planning is complete.')
    lines.push('')
    lines.push('When deriving user stories, format them as:')
    lines.push('- Title: Brief descriptive name')
    lines.push('- Description: "As a [role], I want [feature] so that [benefit]"')
    lines.push('- Acceptance Criteria: Testable conditions for completion')
    lines.push('')

    return lines.join('\n')
  }

  /**
   * Generate architecture branch context
   * Reads architecture content directly from .puffin/architecture.md
   */
  async generateArchitectureBranch(state) {
    const lines = []
    lines.push('---')
    lines.push('')
    lines.push('## Branch Focus: Architecture')
    lines.push('')
    lines.push('You are working on the **architecture thread**. Focus on:')
    lines.push('- System design and component structure')
    lines.push('- Data flow and state management')
    lines.push('- API contracts and interfaces')
    lines.push('- Technology choices and trade-offs')
    lines.push('- Scalability and maintainability')
    lines.push('')

    // Include architecture document from .puffin/architecture.md if available
    try {
      const puffinDir = path.join(this.projectPath, '.puffin')
      const archPath = path.join(puffinDir, 'architecture.md')
      const content = await fs.readFile(archPath, 'utf-8')
      if (content && content.trim()) {
        lines.push('### Current Architecture')
        lines.push('')
        lines.push(content)
        lines.push('')
      }
    } catch (err) {
      // File doesn't exist or can't be read - that's okay, just skip it
    }

    return lines.join('\n')
  }

  /**
   * Generate UI branch context with design tokens and patterns
   */
  generateUiBranch(state) {
    const lines = []
    lines.push('---')
    lines.push('')
    lines.push('## Branch Focus: UI/UX')
    lines.push('')
    lines.push('You are working on the **UI/UX thread**. Focus on:')
    lines.push('- User interface implementation')
    lines.push('- Component design and structure')
    lines.push('- Styling and visual consistency')
    lines.push('- User interactions and feedback')
    lines.push('- Accessibility and responsiveness')
    lines.push('')

    const guidelines = state.uiGuidelines
    if (guidelines) {
      // Design tokens
      if (guidelines.designTokens) {
        const tokens = guidelines.designTokens

        if (tokens.colors && Object.keys(tokens.colors).length > 0) {
          lines.push('### Color Tokens')
          lines.push('')
          lines.push('Use these CSS custom properties for colors:')
          lines.push('')
          lines.push('| Token | Value | Usage |')
          lines.push('|-------|-------|-------|')
          for (const [name, token] of Object.entries(tokens.colors)) {
            lines.push(`| \`--color-${name}\` | \`${token.value}\` | ${token.description || ''} |`)
          }
          lines.push('')
        }

        if (tokens.fontFamilies && tokens.fontFamilies.length > 0) {
          lines.push('### Typography')
          lines.push('')
          tokens.fontFamilies.forEach(f => {
            lines.push(`- **${f.name}:** \`${f.value}\` - ${f.description || ''}`)
          })
          lines.push('')
        }

        if (tokens.fontSizes && tokens.fontSizes.length > 0) {
          lines.push('### Font Sizes')
          lines.push('')
          tokens.fontSizes.forEach(s => {
            lines.push(`- **${s.name}:** \`${s.value}\` - ${s.description || ''}`)
          })
          lines.push('')
        }

        if (tokens.spacing && tokens.spacing.length > 0) {
          lines.push('### Spacing Scale')
          lines.push('')
          tokens.spacing.forEach(s => {
            lines.push(`- **${s.name}:** \`${s.value}\` - ${s.description || ''}`)
          })
          lines.push('')
        }

        if (tokens.radii && tokens.radii.length > 0) {
          lines.push('### Border Radii')
          lines.push('')
          tokens.radii.forEach(r => {
            lines.push(`- **${r.name}:** \`${r.value}\``)
          })
          lines.push('')
        }
      }

      // Component patterns
      if (guidelines.componentPatterns && guidelines.componentPatterns.length > 0) {
        lines.push('### Component Patterns')
        lines.push('')
        guidelines.componentPatterns.forEach(pattern => {
          lines.push(`#### ${pattern.name}`)
          if (pattern.description) {
            lines.push('')
            lines.push(pattern.description)
          }
          if (pattern.guidelines) {
            lines.push('')
            lines.push('**Guidelines:** ' + pattern.guidelines)
          }
          if (pattern.htmlTemplate) {
            lines.push('')
            lines.push('**HTML Template:**')
            lines.push('```html')
            lines.push(pattern.htmlTemplate)
            lines.push('```')
          }
          if (pattern.cssRules) {
            lines.push('')
            lines.push('**CSS:**')
            lines.push('```css')
            lines.push(pattern.cssRules)
            lines.push('```')
          }
          lines.push('')
        })
      }

      // General guidelines
      if (guidelines.guidelines) {
        const g = guidelines.guidelines
        if (g.layout) {
          lines.push('### Layout Guidelines')
          lines.push('')
          lines.push(g.layout)
          lines.push('')
        }
        if (g.components) {
          lines.push('### Component Guidelines')
          lines.push('')
          lines.push(g.components)
          lines.push('')
        }
        if (g.interactions) {
          lines.push('### Interaction Guidelines')
          lines.push('')
          lines.push(g.interactions)
          lines.push('')
        }
      }
    }

    return lines.join('\n')
  }

  /**
   * Generate backend branch context
   */
  generateBackendBranch(state) {
    const lines = []
    lines.push('---')
    lines.push('')
    lines.push('## Branch Focus: Backend')
    lines.push('')
    lines.push('You are working on the **backend thread**. Focus on:')
    lines.push('- API design and implementation')
    lines.push('- Data persistence and database operations')
    lines.push('- Business logic and validation')
    lines.push('- Error handling and logging')
    lines.push('- Security and authentication')
    lines.push('')
    lines.push('## Key Backend Files')
    lines.push('')
    lines.push('| Purpose | Location |')
    lines.push('|---------|----------|')
    lines.push('| Main entry | `src/main/main.js` |')
    lines.push('| IPC handlers | `src/main/ipc-handlers.js` |')
    lines.push('| State management | `src/main/puffin-state.js` |')
    lines.push('| Claude service | `src/main/claude-service.js` |')
    lines.push('| Plugin loader | `src/main/plugin-loader.js` |')
    lines.push('')
    lines.push('## IPC Handler Pattern')
    lines.push('')
    lines.push('```javascript')
    lines.push('ipcMain.handle(\'namespace:action\', async (event, args) => {')
    lines.push('  try {')
    lines.push('    // Validate input')
    lines.push('    // Perform operation')
    lines.push('    return { success: true, data: result }')
    lines.push('  } catch (error) {')
    lines.push('    return { success: false, error: error.message }')
    lines.push('  }')
    lines.push('})')
    lines.push('```')
    lines.push('')

    // Include data model from architecture if available
    if (state.architecture?.content) {
      // Try to extract data model section
      const content = state.architecture.content
      const dataModelMatch = content.match(/##\s*Data\s*Model[\s\S]*?(?=##|$)/i)
      if (dataModelMatch) {
        lines.push('### Data Model')
        lines.push('')
        lines.push(dataModelMatch[0].trim())
        lines.push('')
      }
    }

    return lines.join('\n')
  }

  /**
   * Generate deployment branch context
   */
  generateDeploymentBranch(state) {
    const lines = []
    lines.push('---')
    lines.push('')
    lines.push('## Branch Focus: Deployment')
    lines.push('')
    lines.push('You are working on the **deployment thread**. Focus on:')
    lines.push('- CI/CD pipeline configuration')
    lines.push('- Infrastructure as code')
    lines.push('- Container and orchestration setup')
    lines.push('- Environment configuration')
    lines.push('- Monitoring and logging setup')
    lines.push('')
    lines.push('## Deployment Workflow')
    lines.push('')
    lines.push('1. **Configure** - Set up environment variables and secrets')
    lines.push('2. **Build** - Create production artifacts')
    lines.push('3. **Test** - Run smoke tests and health checks')
    lines.push('4. **Deploy** - Push to target environment')
    lines.push('5. **Verify** - Confirm deployment success')
    lines.push('')
    lines.push('## Key Considerations')
    lines.push('')
    lines.push('- Electron apps require platform-specific builds (Windows, macOS, Linux)')
    lines.push('- Use electron-builder for packaging')
    lines.push('- Code signing required for distribution')
    lines.push('')

    return lines.join('\n')
  }

  /**
   * Generate bug-fixes branch context
   */
  generateBugFixesBranch(state) {
    const lines = []
    lines.push('---')
    lines.push('')
    lines.push('## Branch Focus: Bug Fixes')
    lines.push('')
    lines.push('You are working on the **bug fixes thread**. Focus on:')
    lines.push('- Identifying and diagnosing bugs')
    lines.push('- Root cause analysis')
    lines.push('- Implementing fixes with minimal side effects')
    lines.push('- Adding regression tests')
    lines.push('- Documenting the fix and its rationale')
    lines.push('')
    lines.push('Be thorough in testing and consider edge cases.')
    lines.push('')
    lines.push('## Bug Fix Workflow')
    lines.push('')
    lines.push('1. **Reproduce** - Confirm the bug exists and understand the trigger')
    lines.push('2. **Locate** - Find the root cause in the codebase')
    lines.push('3. **Fix** - Make minimal, targeted changes to resolve the issue')
    lines.push('4. **Test** - Verify fix works and doesn\'t break other functionality')
    lines.push('5. **Document** - Add comments explaining non-obvious fixes')
    lines.push('')
    lines.push('## Debugging Tips')
    lines.push('')
    lines.push('- Use `console.log(\'[COMPONENT] message:\', value)` with component prefixes')
    lines.push('- Check DevTools Console (Ctrl+Shift+I) for renderer process issues')
    lines.push('- Check terminal output for main process issues')
    lines.push('- SAM state changes are logged - look for `[SAM]` prefixed messages')
    lines.push('')
    lines.push('## Common Bug Categories')
    lines.push('')
    lines.push('| Category | Key Files to Check |')
    lines.push('|----------|-------------------|')
    lines.push('| State bugs | `src/renderer/sam/model.js` (acceptors) |')
    lines.push('| IPC issues | `src/main/ipc-handlers.js`, `src/main/preload.js` |')
    lines.push('| UI glitches | `src/renderer/app.js`, `src/renderer/components/` |')
    lines.push('| Plugin errors | `plugins/*-plugin/`, `src/main/plugin-loader.js` |')
    lines.push('')

    return lines.join('\n')
  }

  /**
   * Generate fullstack branch context
   */
  generateFullstackBranch(state) {
    const lines = []
    lines.push('---')
    lines.push('')
    lines.push('## Branch Focus: Fullstack')
    lines.push('')
    lines.push('You are working on the **fullstack thread**. Focus on:')
    lines.push('- End-to-end feature implementation')
    lines.push('- Main process + renderer coordination')
    lines.push('- IPC communication patterns')
    lines.push('- State management across processes')
    lines.push('')
    lines.push('## IPC Patterns')
    lines.push('')
    lines.push('### Request-Response (invoke/handle)')
    lines.push('```javascript')
    lines.push('// Main process')
    lines.push('ipcMain.handle(\'channel:action\', async (event, args) => {')
    lines.push('  return result')
    lines.push('})')
    lines.push('')
    lines.push('// Renderer')
    lines.push('const result = await window.puffin.channel.action(args)')
    lines.push('```')
    lines.push('')
    lines.push('### Events (send/on)')
    lines.push('```javascript')
    lines.push('// Main process')
    lines.push('mainWindow.webContents.send(\'channel:event\', data)')
    lines.push('')
    lines.push('// Renderer')
    lines.push('window.puffin.channel.onEvent(callback)')
    lines.push('```')
    lines.push('')
    lines.push('## Key Integration Points')
    lines.push('')
    lines.push('| Purpose | File |')
    lines.push('|---------|------|')
    lines.push('| IPC handlers | `src/main/ipc-handlers.js` |')
    lines.push('| Preload bridge | `src/main/preload.js` |')
    lines.push('| SAM actions | `src/renderer/sam/actions.js` |')
    lines.push('| SAM model | `src/renderer/sam/model.js` |')
    lines.push('')

    return lines.join('\n')
  }

  /**
   * Generate code-reviews branch context
   */
  generateCodeReviewsBranch(state) {
    const lines = []
    lines.push('---')
    lines.push('')
    lines.push('## Branch Focus: Code Reviews')
    lines.push('')
    lines.push('You are working on the **code review thread**. Focus on:')
    lines.push('- Code quality and maintainability')
    lines.push('- Security vulnerabilities')
    lines.push('- Performance issues')
    lines.push('- Adherence to project conventions')
    lines.push('- Test coverage gaps')
    lines.push('')
    lines.push('## Review Checklist')
    lines.push('')
    lines.push('### Security')
    lines.push('- [ ] No XSS vulnerabilities (escape HTML in user content)')
    lines.push('- [ ] No command/SQL injection risks')
    lines.push('- [ ] No path traversal vulnerabilities')
    lines.push('- [ ] IPC inputs validated')
    lines.push('')
    lines.push('### Code Quality')
    lines.push('- [ ] Error handling for edge cases')
    lines.push('- [ ] Event listeners properly cleaned up')
    lines.push('- [ ] No memory leaks (timers, subscriptions)')
    lines.push('- [ ] Consistent with existing code patterns')
    lines.push('')
    lines.push('### Testing')
    lines.push('- [ ] Unit tests for new functions')
    lines.push('- [ ] Edge cases covered')
    lines.push('- [ ] No broken existing tests')
    lines.push('')

    return lines.join('\n')
  }

  /**
   * Generate improvements branch context
   */
  generateImprovementsBranch(state) {
    const lines = []
    lines.push('---')
    lines.push('')
    lines.push('## Branch Focus: Improvements')
    lines.push('')
    lines.push('You are working on the **improvements thread**. Focus on:')
    lines.push('- Performance optimizations')
    lines.push('- Code refactoring')
    lines.push('- Developer experience enhancements')
    lines.push('- Technical debt reduction')
    lines.push('')
    lines.push('## Improvement Guidelines')
    lines.push('')
    lines.push('- **Measure first** - Profile before and after performance changes')
    lines.push('- **Stay focused** - Keep refactors targeted, don\'t change unrelated code')
    lines.push('- **Maintain compatibility** - Avoid breaking existing functionality')
    lines.push('- **Update tests** - Ensure tests reflect improved code')
    lines.push('')
    lines.push('## Common Improvement Areas')
    lines.push('')
    lines.push('| Area | Focus |')
    lines.push('|------|-------|')
    lines.push('| Performance | Reduce re-renders, optimize loops, lazy loading |')
    lines.push('| Readability | Clear naming, consistent patterns, better docs |')
    lines.push('| Maintainability | DRY principles, modular design, clear interfaces |')
    lines.push('| Developer UX | Better errors, logging, debugging tools |')
    lines.push('')

    return lines.join('\n')
  }

  /**
   * Generate generic branch context for custom branches
   */
  generateGenericBranch(branch, state) {
    const lines = []
    lines.push('---')
    lines.push('')
    lines.push(`## Branch Focus: ${branch.charAt(0).toUpperCase() + branch.slice(1)}`)
    lines.push('')
    lines.push(`You are working on the **${branch}** thread.`)
    lines.push('')

    return lines.join('\n')
  }

  /**
   * Activate a branch by combining base + branch content into CLAUDE.md
   * @param {string} branch - Branch to activate
   */
  async activateBranch(branch) {
    const basePath = path.join(this.claudeDir, 'CLAUDE_base.md')
    const branchPath = path.join(this.claudeDir, `CLAUDE_${branch}.md`)
    const activePath = path.join(this.claudeDir, 'CLAUDE.md')

    let baseContent = ''
    let branchContent = ''

    try {
      baseContent = await fs.readFile(basePath, 'utf-8')
    } catch (err) {
      if (err.code !== 'ENOENT') throw err
    }

    try {
      branchContent = await fs.readFile(branchPath, 'utf-8')
    } catch (err) {
      if (err.code !== 'ENOENT') throw err
      // Fall back to generic if branch file doesn't exist
      branchContent = this.generateGenericBranch(branch, {})
    }

    const combined = baseContent + '\n' + branchContent
    await fs.writeFile(activePath, combined, 'utf-8')

    console.log(`[CLAUDE.md] Activated branch: ${branch}`)
  }

  /**
   * Update only the base file (for config/story changes)
   * @param {Object} state - Puffin state
   * @param {string} activeBranch - Current branch to reactivate
   */
  async updateBase(state, activeBranch) {
    await this.generateBase(state)
    await this.activateBranch(activeBranch)
  }

  /**
   * Update a specific branch file
   * @param {string} branch - Branch to update
   * @param {Object} state - Puffin state
   * @param {string} activeBranch - Current active branch
   * @param {string} [skillContent=''] - Optional plugin skill content to append
   * @param {string} [agentContent=''] - Optional agent content to append
   */
  async updateBranch(branch, state, activeBranch, skillContent = '', agentContent = '') {
    await this.generateBranch(branch, state, skillContent, agentContent)
    if (branch === activeBranch) {
      await this.activateBranch(activeBranch)
    }
  }

  /**
   * Format option value for display
   */
  formatOption(value) {
    const mappings = {
      'HYBRID': 'Hybrid (OOP + FP)',
      'OOP': 'Object-Oriented',
      'FP': 'Functional',
      'TEMPORAL': 'Temporal/Event-Driven',
      'BDD': 'Behavior-Driven Development',
      'TDD': 'Test-Driven Development',
      'INTEGRATION': 'Integration Testing',
      'MINIMAL': 'Minimal',
      'STANDARD': 'Standard',
      'COMPREHENSIVE': 'Comprehensive',
      'EXCEPTIONS': 'Exceptions',
      'RESULT': 'Result Types',
      'EITHER': 'Either Monad',
      'CAMEL': 'camelCase',
      'SNAKE': 'snake_case',
      'PASCAL': 'PascalCase'
    }
    return mappings[value] || value
  }
}

module.exports = ClaudeMdGenerator
